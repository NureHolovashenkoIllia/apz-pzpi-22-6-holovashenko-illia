Міністерство освіти і науки України
Харківський національний університет радіоелектроніки
 Факультет комп’ютерних наук
Кафедра програмної інженерії




ЗВІТ

до практичного заняття №1
з дисципліни "Архітектура програмного забезпечення"
на тему "Патерни проєктування"




Виконав:
ст. гр. ПЗПІ-22-6
Головашенко І. В.

Перевірив:
ст. викл. катедри ПІ
Сокорчук І. П.





Харків 2025
1 ІСТОРІЯ ЗМІН

Таблиця 1.1 – Історія змін
№
Дата
Версія звіту
Опис змін та виправлень
1
25.04.2025
0.1
Створено розділи “Історія змін” та “Опис виконаної роботи”
2
27.04.2025
0.1
Створено розділ “Опис виконаної роботи”
3
01.05.2025
0.1
Створено Додаток А, Додаток Б, та Додаток В



















2 ЗАВДАННЯ

Завдання на практичне заняття 1 (ПЗ1):
1. Підготувати доповідь на тему: «Шаблон (патерн) проєктування ПЗ Стан “State”»
2. Створити та оформити слайди презентації доповіді;
3. Створити та опублікувати на YouTube відеозапис доповіді;
4. Оформити та завантажити на dl.nure.ua звіт до виконаної роботи;
5. При потребі створити та налаштувати у GitHub обліковий запис для облікового запису студента в домені @nure.ua;
6. Створити для виконання завдань з дисципліни GitHub репозиторій iз вказаним на https://dl.nure.ua іменем та з головною гілкою main;
7. Створити у корені створеного репозиторію файл README.md з вказаним далі змістом та вказані далі директорії для окремих завдань;
8. Експортувати звіт у файл у простому текстововому форматі та завантажити цей файл у директорію Pract1 у репозиторії GitHub;
9. Завантажити у вказану далі піддиректорію увесь програмний код, який розглядається у доповіді ПЗ1.









3 ОПИС ВИКОНАНОЇ РОБОТИ

     У межах виконання практичного заняття №1 було вивчено патерн проєктування "Стан" (State). Основна увага була приділена теоретичному аналізу сутності патерна, виявленню проблем, які він дозволяє вирішувати, та вивченню типової структури реалізації.
     Проведено дослідження типових сценаріїв використання патерна "Стан" у програмному забезпеченні, зокрема в контексті скінченних автоматів. Для кращого розуміння було наведено приклад проблеми з переходами станів у коді без використання патерна, що призводить до великої кількості умовних операторів і погіршення підтримуваності коду.
     Було реалізовано приклад на мові програмування Kotlin, який демонструє переваги використання патерна "Стан" для організації поведінки об’єкта в залежності від його поточного стану. Реалізація включає створення базового інтерфейсу UserState, кількох конкретних станів, а також контекстного класу, який делегує поведінку поточному стану. Цей підхід дозволяє уникнути складної логіки умовних операторів і забезпечити гнучке розширення системи.
     Також було створено слайди презентації для супроводу усної доповіді, підготовлено відеозапис пояснення теми та завантажено його на YouTube. Посилання на відеозапис доповіді та текст хронологічного опису доповіді наведено у Додатку А.




4 ВИСНОВКИ

     У результаті виконання практичного завдання було здобуто практичні навички застосування патерна "Стан" у проєктуванні програмного забезпечення. Розглянутий патерн дозволяє спростити реалізацію поведінки об’єктів, що змінюється залежно від внутрішнього стану, та значно підвищити гнучкість і підтримуваність коду.
     Патерн "Стан" особливо корисний у розробці скінченних автоматів, GUI-додатків, ігрової логіки та інших систем із чіткими переходами між режимами роботи. Його використання дозволяє уникнути надмірної кількості умовних конструкцій та спрощує додавання нових станів без зміни існуючого коду.
     Слайди презентації наведено у Додатку Б. Програмний код використаний для наочного прикладу застосування патерна "Стан" наведено у Додатку В.
     Посилання на GitHub репозиторій: https://github.com/NureHolovashenkoIllia/apz-pzpi-22-6-holovashenko-illia/tree/main/Pract1








5 СПИСОК ВИКОРИСТАНИХ ДЖЕРЕЛ

Список використаних джерел
1. Стан. Refactoring and Design Patterns. URL: https://refactoring.guru/uk/design-patterns/state (дата звернення: 01.05.2025).
2. Стан (шаблон проєктування) – Вікіпедія. Вікіпедія. URL: https://uk.wikipedia.org/wiki/Стан_(шаблон_проєктування) (дата звернення: 01.05.2025).
3. Gamma E. Design patterns: Elements of reusable object orientated software. Reading, USA : Addison-Wesley, 1995. 395 с.


















Додаток А
Посилання на відеозапис доповіді та текст хронологічного опису доповіді

Відеозапис доповіді на YouTube:
Хронологічний опис відеозапису:
























Додаток Б
Слайди презентації доповіді






































Додаток В
Приклади програмного коду

     Програмний код для змінення відображення інтерфейсу залежно від статусу користувача до застосування патерна “Стан”
1. @Composable
2. fun UserScreen(userStatus: String, modifier: Modifier = Modifier) {
3.     when (userStatus) {
4.         "guest" -> {
5.             Text("Ласкаво просимо! Будь ласка, увійдіть у систему.",
6.                 modifier = modifier)
7.         }
8.         "user" -> {
9.             Text("Вітаємо вас у вашому профілі.",
10.                 modifier = modifier)
11.        }
12.        "admin" -> {
13.            Text("Доступ до панелі адміністратора.",
14.                modifier = modifier)
15.        }
16.        else -> {
17.            Text("Невідомий статус користувача.",
18.                modifier = modifier)
19.        }
20.    }
21. }


     Програмний код для змінення відображення інтерфейсу залежно від статусу користувача після застосування патерна “Стан”
1. interface UserState {
2.     @Composable
3.     fun RenderScreen()
4. }
5.
6. class GuestState : UserState {
7.     @Composable
8.     override fun RenderScreen() {
9.         Text("Ласкаво просимо! Будь ласка, увійдіть у систему.")
10.     }
11. }
12.
13. class UserStateImpl : UserState {
14.     @Composable
15.     override fun RenderScreen() {
16.         Text("Вітаємо вас у вашому профілі.")
17.     }
18. }
19.
20. class AdminState : UserState {
21.     @Composable
22.     override fun RenderScreen() {
23.         Text("Доступ до панелі адміністратора.")
24.     }
25. }
26.
27. class UnknownState : UserState {
28.     @Composable
29.     override fun RenderScreen() {
30.         Text("Невідомий статус користувача.")
31.     }
32. }
33.
34. class UserContext(status: String) {
35.     val userState: UserState = when (status) {
36.         "guest" -> GuestState()
37.         "user" -> UserStateImpl()
38.         "admin" -> AdminState()
39.         else -> UnknownState()
40.     }
41. }
42.
43. @Composable
44. fun UserScreen(userStatus: String) {
45.     val context = UserContext(userStatus)
46.     context.userState.RenderScreen()
47. }